.TH bash_script 7 "Miscellaneous Information Manual"
.SH NAME
.B bash_script
\- Bash scripting cheat sheet
.SH DESCRIPTION
.PP
This is not (yet) an organized cheat sheet.
For now, it is simply a place where I can save simple scripting
techniques that I don't use frequently enough to memorize.
.SH STRING MANIPULATIONS
.TP
.B Grab filename from path
.EX
declare path="/usr/share/man/man1/grep.1.gz"
declare file="\(Do{path##*/}"  # trim prefix ending in \(lq/\(rq
declare root="\(Do{file%%.*}"  # trim suffix starting with \(lq.\(rq
.EE
.SH READ BUILTIN SPECIAL CASES
.PP
Special case hints to get you started.
.SS READ ALTERNATE SOURCES OF DATA
.PP
The
.B read
command reads from
.IR stdin .
Besides simply reading
.IR stdin ,
there are three other ways to provide
.I stdin
data:
.TS
tab(|);
lb lb
l l.
source|code
from a file|T{
.EX
while read -r; do
   use_reply \(dq$REPLY\(dq;
done < \(dq$filename\(dq
.EE
T}

from a string|T{
.EX
while read -r; do
   use_reply \(dq$REPLY\(dq;
done <<< \(dq$string\(dq
.EE
T}

T{
from process output
.br
AKA
.RI \(dq "process substitution" \(dq
T}|T{
.EX
while read -r; do
   use_reply \(dq$REPLY\(dq;
done < <( awk -f script.awk ~/data.dat )
.EE
T}

T{
from string of value pairs, ':' between
pairs,'=' between values
T}|T{
.EX
declare -a heap
while IFS='=' read -d ':' -a row; do
   heap+=( \(dq\(Do{row[@]}\(dq )
done < \(dq\(DoLS_COLORS\(dq
.EE
T}

T{
To preserve leading- and trailing-
spaces, set an empty IFS
T}|T{
.EX
while IFS=\(aq\(aq read -r; do
   use_reply \(dq\(doREPLY\(dq
done
.EE
T}
.TE
.TP
.B Read Warning
If
.B LS_COLORS
above did not end with the ':' delimiter, the last value pair would
have been read but not processed.
To process an unprocessed
.BR read -parsed
element, follow the
.B while-read
loop with something similar to:
.IP "" 11
.EX
# Process complete but unprocessed element:
if [ \(dq\(Do{row[*]}\(dq -eq 2 ]; then
   heap+=( \(dq\(Do{row[@]}\(dq )
fi
.EE

.SS READ PERFORMANCE HINTS
.TP
.B Preserving spaces
By default,
.B read
respects the
.B IFS
value.
That means that
.B read
will discard leading and trailing spaces, and will compress consecutive
internal spaces into a single space.
.IP
To preserve spaces, set
.B IFS
to an empty string.
.TP
.B Avoid subshells
Avoid having the
.B read
command operate within a subshell.
If that happens, the variables in which the contents were
read will be inaccessible because they will have been discarded
when the subshell ends.
Don't forget that piping output creates subshells.
.IP
Construct your
.B read
like this:
.RS 11
.EX
while read -r; do
   USE \(dq&REPLY\(dq
done < <( awk -f script /etc/passwd )
.EE
.RE
.IP
Don't do this:
.RS 11
.EX
awk -f script /etc/passwd | while read -r; do
   use \(dq$REPLY\(dq
done
.EE
.RE
.PP
.SH RANDOM QUICK SOLUTIONS
.PP
Some things are easy to do, if you know what to do.
.SS File Contents to String
.PP
Read entire contents to a variable in one go.
.IP
.EX
declare file_contents
file_contents=$(<content.txt)
.EE
.SS Process Output to String
.PP
Save output of a process (or two, or more) to a variable.
The example below directs output of two processes,
.BR cat " and " xsltproc ,
to a variable.
.IP "" 4
.EX
declare process_result
process_result=$(< <( cat file.txt; xsltproc file.xsl file.xml ) )
.EE
.SS Two-way Array Conversions
.PP
One really nice feature of using
.B read
to split strings into arrays is that when the
.B IFS
value is set before and on the same line as the
.B read
command, the
.B IFS
value only affect the
.B read
command and does not change the global
.B IFS
value.
.PP
This section demonstrates how to use the one-line construction for
both string-to-array as well as array-to-string operations.
.TP
.B Array from string
.EX
IFS='|' read -r -a array <<< \(dqone|two|three\(dq
.EE
.TP
.B Array of lines from text file
IFS=\(Do\(aq\(rsn\(aq read -d \(dq\(dq -r -a array_target < file_name
.TP
.B String from array
This is trickier.
In-line temporary
.B IFS
assignment is not possible with an assignment statement.
Here are two ways to make the assignment in a function, the calling
of which is eligible for the in-line
.B IFS
assignment.
.IP
.B NOTE:
Sadly, this method will not work for
.BR echo " or " printf
because the argument in which the array expansion resides is processed
before the function is called, so it's too late for the
.B IFS
value to be respected.
Either save and restore the original
.B IFS
around the
.BR echo " or " printf
statement, or convert the array to a string in a previous
statement then use the string with
.BR echo " or " printf .
.RS 7
.TP 4
.B Bespoke join function
You can make a quick-and-dirty function that hard-codes the operation
on the string target and the array source:
.IP
.RS 8
.EX
temp_setter() { target=\(dq\(Do{array[*]}\(dq; }
IFS='|' temp_setter
.EE
.RE
.TP 4
.B Generic join function
If the script often concatenates arrays, a reusable function may be
more suitable.
.IP "" 4
This
.B join_array
function will use an existing variable or create it if it doesn't
exist.
.IP "" 8
.EX
join_array()
{
   if ! declare -p \(dq\(Do1\(dq 1>/dev/null 2>&1; then
      if ! declare -g \(dq\(Do1\(dq; then exit 1; fi
   fi
   local -n ca_target=\(dq\(Do1\(dq
   local -n ca_source=\(dq\(Do2\(dq
   ca_target=\(dq\(Do{ca_source[*]}\(dq
}
.EE
.IP "" 4
Then call it like this:
.IP "" 8
.EX
IFS=\(Do\(aq|\(aq join_array flines my_big_array
.EE

.RE
.SS Error Output Redirection
.PP
For times when the warning error output overwhelms the desired output,
a user can redirect
.B stderr
to
.B /dev/null
or to a file.
.IP
.EX
grep \(dqtarget\(dq * 2>/dev/null
grep \(dqtarget\(dq * 2>/temp/greperror
.EE
.SS Heredoc to String
.PP
Create a mulitline string variable with a
.BR heredoc .
.IP
.EX
declare NLString
read -r -d '' "NLString" << EOF
abcdefghij
0123456789
EOF
.EE
.PP
The heredoc will ignore any single leading TABs from the lines
when using
.IR <<- " instead of " << .
.IP
.EX
declare NLString
read -r -d '' "NLString" <<- EOF
   abcdefghij
   0123456789
EOF
.EE
.PP
The termination string will be recognized with or without the
leading TAB.
.SS Heredoc to Array
.PP
Compound statements cannot be parsed by line, so initializing arrays
with values that might contain spaces needs a different concise
expression.
.IP
.EX
IFS=\(Do\(aq\(rsn\(aq read -r -d '' -a array_name <<EOF
    African bush elephant
    Asian elephant
    African forest elephant
    White rhinoceros
    Hippopotamus
    Indian rhinoceros
    Black rhinoceros
    Javan rhinoceros
    Giraffe
    Gaur
EOF

.EE
.SS Heredoc to Screen
.PP
Use a heredoc rather than a long series of
.B echo
commands for user dialogs.  Remember that a heredoc mimics a file,
so use
.BR cat " instead of " echo :
.IP
.EX
cat <<EOF
my_script [-s source] [-t target] [-h]

-s    Name of file to be read
-t    Name of file to write
-h    help (this display)

EOF
.EE

.SS Do-nothing Function
.PP
Suitable for a default callback in case a callback function is not
provided in certain situations:
.IP
.EX
do_nothing() { :; }
.EE
.SS Iterate Over Characters of a String
.PP
My testing shows this to be the fastest method:
.IP
.EX
# -r     to preserve backslashes
# -n1    to read one character at a time
# -d \(aq\(aq  disable end-of-entry delimiter
while IFS= read -r -n1 -d \(aq\(aq; do
   use_reply \(dq$REPLY\(dq
done <<< \(dq$string\(dq
.EE
.SS Parse String Including Quote-encloded Values Into an Array
.PP
Rather than parsing quote-enclosed phrases in a string, exploit an
unusual
.B declare
syntax to split the string:
.IP
.EX
# String representing three values, a two-word
# value, a one-word value, and an empty value:
declare string=\(dq\(rs\(dqget milk\(rs\(dq now \(rs\(dq\(rs\(dq\(dq

declare -a \(dqitems=($string)\(dq
echo \(dq\(Do{#items[@]} items in items array.\(dq
.EE
.SS Get Absolute Path to Script
.PP
Even though a script is called through an isolated symlink, the script
can find files relative to the scipt's absolute path using the
.B readlink
command.
.IP
.EX
declare SPATH=$( readlink -f \(dq$0\(dq ) # path to script
declare RPATH=\(dq\(Do{SPATH%/*}/\(dq        # path to directory
.EE
.SS When a Scripted Command Must Run in Parent Shell
.PP
Several times I have written a script to apply complicated computed
arguments to a command, only to have it fail because the command only
applies to the current shell, which is lost when the script ends.
.PP
The solution is to write a script that only outputs the arguments to
the sensitive command, then apply the arguments to the command with
a subshell:
.IP
.EX
$ enable $( enable_bfm )
.EE
.SH REGULAR EXPRESSIONS
.PP
Some Bash-specific meta-characters may require escaping with a
single backslash (\(rs) to avoid misinterpretation when assigning
a string:
.br
.B |&;()<> space tab newline
.PP
In Bash, regular expression (regex) meta-characters must be escaped
to be intpreted literally:
.br
.B ()[]{}?+*^$|.
.PP
In a Bash string, a single backslash will force the shell to literally
interpret the escaped character.  Mind the exceptions like \(rst, which
is a tab character rather than an \(dqt\(dq.
.PP
The regex meta-characters must be escaped to be interpreted as literal
characters.
However, a literal backslash \(dq\(rs\(dq must itself be escaped to
prevent it from escaping the following character.
Thus, for most regex meta-characters, when expressed in Bash, must
be preceeded with a double-backslash when included in a string to be
assigned to a regex.
.PP
Some Regular-expression meta-characters may require escaping with
a double-backslash \(dq\(rs\(rs\(dq.
.PP
The following email parsing example will illustrate how the above
rules apply in different situations:
.PP
.EX
.RS 4
declare -a regex_arr=(
.RS 4
.TS
tab(|);
l lx.
\(rs\(rs\(rs(\(rs*|T{
# Optional enclosing parenthesis,
# triple-backslash the parentheses, two to
# preserve the backslash to persist into the
# regex, and one more to prevent interpretation
# as introducing a subshell.
# Single backslash the quantifier \(dq*\(dq to use
# as a regex meta-character, but to avoid
# expansion to a list of file (a \(dq?\(dq would
# be a better regex choice, but it would fail
# to make the point).
T}

\(rs([^@]+\(rs)|T{
# \fBFor name capture\fP, single-escape the grouping
# parentheses to preempt shell interpretation
# as a subshell, but maintaining the regex
# meta-character meaning.
T}

@|T{
# no escaping necessary to match a literal
# character that is neither a regex nor a shell
# metacharacter.
T}

\(rs(.\(rs*\(rs)|T{
# \fBFor subdomain capture\fP, single escape for
# asterisk \(dq*\(dq because it's used here as a
# quantifier, not a literal asterisk.
T}

\(rs\(rs.|T{
# Escape for regex, not the shell: only two
# backslashes.
T}

\(rs([^\(rs)]+\(rs)|T{
# \fBFor domain capture\fP 
T}

\(rs\(rs\(rs)?|T{
# Final match for optional closing parenthesis,
# properly quantified with a \(dq?\(dq.
T}
.TE
.RE
)
.RE
.EE
.SH EDITOR SETUP
.PP
If omitting the
.B shebang
for some reason (ie the script is not intended to run alone), neither
.BR Emacs " nor " Shellcheck
will know how to handle the script.
The following code fragment shows how to identify
.B Bash
mode without the
.BR shebang :
.IP
.EX
# -*- mode:shell-script; sh-shell:bash -*-
# shellcheck shell=bash
.EE

