.TH bash_script 7 "Miscellaneous Information Manual"
.SH NAME
.B bash_script
\- Bash scripting cheat sheet
.SH DESCRIPTION
.PP
This is not (yet) an organized cheat sheet.
For now, it is simply a place where I can save simple scripting
techniques that I don't use frequently enough to memorize.
.SH STRING MANIPULATIONS
.TP
.B Grab filename from path
.EX
declare path="/usr/share/man/man1/grep.1.gz"
declare file="\(Do{path##*/}"  # trim prefix ending in \(lq/\(rq
declare root="\(Do{file%%.*}"  # trim suffix starting with \(lq.\(rq
.EE
.SH READ BUILTIN SPECIAL CASES
.PP
Special case hints to get you started.
.SS READ ALTERNATE SOURCES OF DATA
.PP
The
.B read
command reads from
.IR stdin .
Besides simply reading
.IR stdin ,
there are three other ways to provide
.I stdin
data:
.TS
tab(|);
lb lb
l l.
source|code
from a file|T{
.EX
while read -r; do
   use_reply \(dq$REPLY\(dq;
done < \(dq$filename\(dq
.EE
T}

from a string|T{
.EX
while read -r; do
   use_reply \(dq$REPLY\(dq;
done <<< \(dq$string\(dq
.EE
T}

T{
from process output
.br
AKA
.RI \(dq "process substitution" \(dq
T}|T{
.EX
while read -r; do
   use_reply \(dq$REPLY\(dq;
done < <( awk -f script.awk ~/data.dat )
.EE
T}
.TE
.SS READ PERFORMANCE HINTS
.TP
.B Preserving spaces
By default,
.B read
respects the
.B IFS
value.
That means that
.B read
will discard leading and trailing spaces, and will compress consecutive
internal spaces into a single space.
.IP
To preserve spaces, set
.B IFS
to an empty string.
.TP
.B Avoid subshells
Avoid having the
.B read
command operate within a subshell.
If that happens, the variables in which the contents were
read will be inaccessible because they will have been discarded
when the subshell ends.
Don't forget that piping output creates subshells.
.IP
Construct your
.B read
like this:
.RS 12
.EX
while read -r; do
   USE \(dq&REPLY\(dq
done < <( awk -f script /etc/passwd )
.EE
.RE
.IP
Don't do this:
.RS 12
.EX
awk -f script /etc/passwd | while read -r; do
   use \(dq$REPLY\(dq
done
.EE
.RE
.PP
.SH RANDOM QUICK SOLUTIONS
.PP
Some things are easy to do, if you know what to do.
.SS File Contents to String
.PP
Read entire contents to a variable in one go.
.IP
.EX
declare file_contents
file_contents=$(<content.txt)
.EE
.SS Process Output to String
.PP
Save output of a process (or two, or more) to a variable.
The example below directs output of two processes,
.BR cat " and " xsltproc ,
to a variable.
.IP
.EX
declare process_result
process_result=$(< <( cat sample.txt; xsltproc basic.xsl basic.xml ) )
.EE
.SS Error Output Redirection
.PP
For times when the warning error output overwhelms the desired output,
a user can redirect
.B stderr
to
.B /dev/null
or to a file.
.IP
.EX
grep \(dqtarget\(dq * 2>/dev/null
grep \(dqtarget\(dq * 2>/temp/greperror
.EE
.SS Heredoc to String
.PP
Create a mulitline string variable with a
.BR heredoc .
.IP
.EX
declare NLString
read -r -d '' "NLString" << EOF
abcdefghij
0123456789
EOF
.EE
.PP
The heredoc will ignore any single leading TABs from the lines
when using
.IR <<- " instead of " << .
.IP
.EX
declare NLString
read -r -d '' "NLString" <<- EOF
   abcdefghij
   0123456789
EOF
.EE
.PP
The termination string will be recognized with or without the
leading TAB.
.SS Heredoc to Screen
.PP
Use a heredoc rather than a long series of
.B echo
commands for user dialogs.  Remember that a heredoc mimics a file,
so use
.BR cat " instead of " echo :
.IP
.EX
cat <<EOF
my_script [-s source] [-t target] [-h]

-s    Name of file to be read
-t    Name of file to write
-h    help (this display)

EOF
.EE

.SS Do-nothing Function
.PP
Suitable for a default callback in case a callback function is not
provided in certain situations:
.IP
.EX
do_nothing() { :; }
.EE
.SS Iterate Over Characters of a String
.PP
My testing shows this to be the fastest method:
.IP
.EX
# -r     to preserve backslashes
# -n1    to read one character at a time
# -d \(aq\(aq  disable end-of-entry delimiter
while IFS= read -r -n1 -d \(aq\(aq; do
   use_reply \(dq$REPLY\(dq
done <<< \(dq$string\(dq
.EE
.SS Parse String of Values Into an Array
.PP
Rather than parsing quote-enclosed phrases in a string, use
a system tool to separate the values:
.IP
.EX
# $1 is name of array variable
# $2 is string of values (ie 3 values in \fB1 \(dqthe best\(dq https://url.com\fP)
arrayify_string()
{
   local -n as_array=\(dq$1\(dq
   IFS=$\(aq\(rsn\(aq as_array=( $( xargs -n1 <<< \(dq$2\(dq ) )
}
.EE
.SS Get Absolute Path to Script
.PP
Even though a script is called through an isolated symlink, the script
can find files relative to the scipt's absolute path using the
.B readlink
command.
.IP
.EX
declare SPATH=$( readlink -f \(dq$0\(dq ) # path to script
declare RPATH=\(dq\(Do{SPATH%/*}/\(dq        # path to directory
.EE
.SS When a Scripted Command Must Run in Parent Shell
.PP
Several times I have written a script to apply complicated computed
arguments to a command, only to have it fail because the command only
applies to the current shell, which is lost when the script ends.
.PP
The solution is to write a script that only outputs the arguments to
the sensitive command, then apply the arguments to the command with
a subshell:
.IP
.EX
$ enable $( enable_bfm )
.EE
.SH REGULAR EXPRESSIONS
.PP
Some Bash-specific meta-characters may require escaping with a
single backslash (\(rs) to avoid misinterpretation when assigning
a string:
.br
.B |&;()<> space tab newline
.PP
In Bash, regular expression (regex) meta-characters must be escaped
to be intpreted literally:
.br
.B ()[]{}?+*^$|.
.PP
In a Bash string, a single backslash will force the shell to literally
interpret the escaped character.  Mind the exceptions like \(rst, which
is a tab character rather than an \(dqt\(dq.
.PP
The regex meta-characters must be escaped to be interpreted as literal
characters.
However, a literal backslash \(dq\(rs\(dq must itself be escaped to
prevent it from escaping the following character.
Thus, for most regex meta-characters, when expressed in Bash, must
be preceeded with a double-backslash when included in a string to be
assigned to a regex.
.PP
Some Regular-expression meta-characters may require escaping with
a double-backslash \(dq\(rs\(rs\(dq.
.PP
The following email parsing example will illustrate how the above
rules apply in different situations:
.PP
.EX
.RS 4
declare -a regex_arr=(
.RS 4
.TS
tab(|);
l lx.
\(rs\(rs\(rs(\(rs*|T{
# Optional enclosing parenthesis,
# triple-backslash the parentheses, two to
# preserve the backslash to persist into the
# regex, and one more to prevent interpretation
# as introducing a subshell.
# Single backslash the quantifier \(dq*\(dq to use
# as a regex meta-character, but to avoid
# expansion to a list of file (a \(dq?\(dq would
# be a better regex choice, but it would fail
# to make the point).
T}

\(rs([^@]+\(rs)|T{
# \fBFor name capture\fP, single-escape the grouping
# parentheses to preempt shell interpretation
# as a subshell, but maintaining the regex
# meta-character meaning.
T}

@|T{
# no escaping necessary to match a literal
# character that is neither a regex nor a shell
# metacharacter.
T}

\(rs(.\(rs*\(rs)|T{
# \fBFor subdomain capture\fP, single escape for
# asterisk \(dq*\(dq because it's used here as a
# quantifier, not a literal asterisk.
T}

\(rs\(rs.|T{
# Escape for regex, not the shell: only two
# backslashes.
T}

\(rs([^\(rs)]+\(rs)|T{
# \fBFor domain capture\fP 
T}

\(rs\(rs\(rs)?|T{
# Final match for optional closing parenthesis,
# properly quantified with a \(dq?\(dq.
T}
.TE
.RE
)
.RE
.EE
.SH EDITOR SETUP
.PP
If omitting the
.B shebang
for some reason (ie the script is not intended to run alone), neither
.BR Emacs " nor " Shellcheck
will know how to handle the script.
The following code fragment shows how to identify
.B Bash
mode without the
.BR shebang :
.IP
.EX
# -*- mode:shell-script; sh-shell:bash -*-
# shellcheck shell=bash
.EE

